# 查询处理 1 (Query Execution I)

---

## 1 概述

查询处理涉及到的`基本操作`是：解析并翻译、优化、求值。

`计算原语(evaluation primitive)`：有指令注解如何执行的一个关系代数操作。

`查询执行计划(query-execution plan)`：可以用于执行一个查询的执行原语序列。

`查询执行引擎(query-execution engine)`：接受一个查询执行计划，执行它并且将结果返回给查询。

多个操作可能由`流水线`组合到一起，在一个操作仍在处理时，将已有的输出传递给下一个操作。为了优化一个查询，查询优化器必须要能够评估不同优化方式的大致开销。

---

## 2 查询代价的度量

为能够在多个不同的查询优化方案中选择一个最好的，需要能够测量不同查询优化方案的大致开销。涉及到的测量指标包括：CPU计算用时、磁盘访问时间和通信用时。

在以磁盘为存储介质的数据库系统中，总开销主要受到磁盘访问开销的影响。以`块传输次数`和`随机访问次数`这两个指标来衡量磁盘访问开销。块传输单位时间和随机访问单位时间可以是数据库系统在安装时候自动测试获得，也可以是用户手动配置。

一般来说，磁盘写操作会慢于读操作，查询所需的块也可能就在内存缓冲区中，为了便于计算，我们忽略这两种情况。另外，最后结果的写入是单独计算的。

查询的响应时间是执行查询的墙上时钟时间。但查询响应时间的测量很难在优化时得到较准确结果，因为内存缓冲区的可用块数和是否有其他并发任务抢占资源很难把握。所以，优化的目标一般是减少资源消耗而非响应时间。虽然有时资源消耗少并不一定意味着响应时间少。

---

## 4 处理模型

**迭代器模型** 亦称火山模型或流水线模型。每一节点通过调用子节点的Next函数即可获得下一个待处理的元组。这种方法具有高度的组合性、易于实现以及输出控制的优点。但频繁的函数调用是它的一个缺点。

**物化模型** 是一种特殊的迭代器模型。它一次获取子节点操作结果的所有元组以及产生所有结果。

**向量化模型** 是一种特殊的迭代器模型。它一次获取子节点操作的一批元组以及产生一批结果。每批元组的大小取决于查询的性质以及硬件性质。

---

## 5 访问方式

总的来说，访问方式包括`连续扫描`和`索引扫描`两种。`连续扫描`包括预取、缓冲区旁路、并行扫描、迟物化、堆集群以及数据跳过(包括信息损失的估测扫描以及信息无损的空间映射)。`索引扫描`通过索引来定位需要的文件。在有多个索引以及多个属性值在WHERE从句时，通过取多个索引的交或并比使用单索引有更好的效果。索引扫描的优化效果受到有哪些索引、从句涉及的属性、索引值域、判词组合以及索引码是否唯一这几个因素的影响。

---

## 6 选择运算

`文件扫描` 是最低级的访问数据的运算符。

### 6.1 用文件扫描和索引的选择运算

* A1: 线性搜索

* A2: 主索引，码属性等值比较 

* A3: 主索引，非码属性等值比较

* A4: 辅助索引，等值比较

### 6.2 涉及比较的选择

* A5: 主索引，比较

* A6: 辅助索引，比较

当只是使用辅助索引来实现涉及比较的选择时，最坏情况下可能代价比线性搜索高出不少。PostgreSQL的bitmap index scan算法是辅助索引与线性搜索的杂合方案。能够保证在最好情况下，比最好的查询执行计划低些许性能。

### 6.3 复杂选择的实现

* A7: 用一个索引的合取选择

* A8: 用复合索引的合取操作

* A9: 通过标识符的交实现的合取操作

* A10: 通过标识符的并实现的析取操作

---

## 7 修改性查询

在处理带有Update, Insert和Delete这三个操作的问询时，需要更改表中的目标元组以及相关的索引。在插入操作的实现中，有立即物化和物化子节点返回的元组两个选择。

Halloween Problem指的是更新操作改变了一个元组的位置导致查询中访问该元组多次。解决方法是在查询中保留更改过的元组的相关信息。

---

## 8 表达式的计算

### 8.1 物化

物化执行是表达式树上的一个非根节点产生的中间关系存放于持久性存储设备上并在下一级中被使用的执行方式。其成本包括所有操作的结果写出成本产生的块传输时间以及寻道时间。一个优化方法是双缓冲区算法，提高CPU和IO的并行性。通过分配更多的输出缓冲块能够减少寻道时间。

### 8.2 流水线

流水线执行是非根节点操作产生的中间结果直接传递给高一级节点操作作为输入的执行方式。它能够减少读写中间文件的开销以及一个操作可以快速的启动。流水线执行包括需求驱动的流水线执行和生产驱动的流水线执行。

#### 8.2.1 流水线的实现

**需求驱动的流水线执行** 从根节点开始，依次向下发送对元组的需求。可以通过迭代器来实现。是一种懒惰的拉数据操作。

**生产驱动的流水线执行** 从底层节点开始，将结果写入输出缓冲区至缓冲区满，随后等待上层节点将结果取出，接下来继续执行。是一种积极的推数据操作。

需求驱动的流水线更便于实现，但生产驱动的流水线有更高的并行性。

### 8.2.2 流水线的运算算法

流水线化的边连接两个流水线操作节点，物化的边连接两个物化操作节点。在一颗操作符树中，一颗边全是流水线化的边的子树称为流水线阶段。一个物化操作有时可以拆分为几个可以流水线的子操作。双流水线连接技术是用于流水线化输入和输出的连接算法，双流水线哈希连接技术是它的更优技术。

### 8.2.3 连续流式数据的流水线

为了一旦数据到达就响应，执行需要基于流式数据而写。这样的执行称为连续执行。连续执行的合适实现方法是生产驱动的流水线。

### 8.3 表达式优化

完全遍历整棵表达式树可能会产生性能损耗。开启优化可以让DBMS将一颗表达式树优化为一个函数执行，从而免去遍历整棵树。
