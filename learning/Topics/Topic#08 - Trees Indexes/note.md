# B+ Tree

---

## 结构

设一个节点包含N-1个键位以及N个指针位。

**叶节点：** N-1个指针用于指向每个键所对应的文件记录位置，第N个指针用于指向邻节点。节点必须至少含有⌈(N − 1)∕2⌉个值，最多N-1个值。存储的值是有序的。

**内节点：** N个指针均用于指向非空子节点。所存储指针数的要求 ⌈N∕2⌉<= # <= N。其他要求除指针所指内容外，同叶节点。

**根节点：** 至少存储两个指针，除非整棵树只有一个节点。

注：内节点可能包含实际上不存在于树的值，其起引导作用。在实现B+Tree时，注意节点类型以及不同类型的数量要求、指针内容、有序性以及指引性(对于每一个内节点的值，分为小于它和大于等于它的两部分)。

---

## 操作

**查找：** 根据内节点的指引性以及有序性来遍历树。

**插入：** 插入元素为v

* 找到v应该在的叶节点L。

* 如果L有足够的空间，那么插入v并保证有序性，完成。反之，将L平均分为L和L'两个节点，再将v插入到合适的节点，随后把中间元素拷贝到L的父节点。

* 内节点重分配时，将中间元素移动到父节点而非拷贝到。

**删除：** 删除元素为v

* 找到v应该在的叶节点L。

* 删除元素v并保持有序性。如果删除后节点存储值的数量满足要求，完成。反之，将该节点与邻节点合并，并且删除父结点中对应的指针。

* 如果合并后导致父节点不满足数量要求，对父节点需要合并。可能存在递归情况（？）。
